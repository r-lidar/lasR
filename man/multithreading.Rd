% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/openmp.R
\name{multithreading}
\alias{multithreading}
\alias{set_parallel_strategy}
\alias{unset_parallel_strategy}
\alias{get_parallel_strategy}
\alias{ncores}
\alias{half_cores}
\alias{sequential}
\alias{concurrent_files}
\alias{concurrent_points}
\alias{nested}
\alias{has_omp_support}
\title{Parallel processing tools}
\usage{
set_parallel_strategy(strategy)

unset_parallel_strategy()

get_parallel_strategy()

ncores()

half_cores()

sequential()

concurrent_files(ncores = half_cores())

concurrent_points(ncores = half_cores())

nested(ncores = ncores()/4L, ncores2 = 2L)

has_omp_support()
}
\arguments{
\item{strategy}{An object returned by one of \code{sequential()}, \code{concurrent_points()}, \code{concurrent_files} or
\code{nested()}.}

\item{ncores}{integer. Number of cores.}

\item{ncores2}{integer.  Number of cores. For \code{nested} strategy \code{ncores} is the number of concurrent
files and \code{ncores2} is the number of concurrent points.}
}
\description{
\code{lasR} uses OpenMP to paralellize the internal C++ code. \code{set_parallel_strategy()} globally changes
the strategy used to process the point clouds. \code{sequential()}, \code{concurrent_files()},
\code{concurrent_points()}, and \code{nested()} are functions to assign a parallelization strategy (see Details).
\code{has_omp_support()} tells you if the \code{lasR} package was compiled with the support of OpenMP which
is unlikely to be the case on MacOS.
}
\details{
There are 4 strategies of parallel processing:
\describe{
\item{sequential}{No parallelization at all: \code{sequential()}}
\item{concurrent-points}{Point cloud files are processed sequentially one by one. Inside the pipeline,
some stages are parallelized and are able to process multiple points simultaneously. Not all stages
are natively parallelized. E.g. \code{concurrent_points(4)}}
\item{concurrent-files}{Files are processed in parallel. Several files are loaded in memory
and processed simultaneously. The entire pipeline is parallelized, but inside each stage,
the points are processed sequentially. E.g. \code{concurrent_files(4)}}
\item{nested}{Files are processed in parallel. Several files are loaded in memory
and processed simultaneously, and inside some stages, the points are processed in parallel. E.g. \code{nested(4,2)}}
}
\code{concurrent-files} is likely the most desirable and fastest option. However, it uses more memory
because it loads multiple files. The default is \code{concurrent_points(half_cores())} and can be changed
globally using e.g. \code{set_parallel_strategy(concurrent_files(4))}
}
\examples{
\dontrun{
f <- paste0(system.file(package="lasR"), "/extdata/bcts/")
f <- list.files(f, pattern = "(?i)\\\\.la(s|z)$", full.names = TRUE)

pipeline <- reader_las() + rasterize(2, "imean")

ans <- exec(pipeline, on = f, progress = TRUE, ncores = concurrent_files(4))

set_parallel_strategy(concurrent_files(4))
ans <- exec(pipeline, on = f, progress = TRUE)
}
}

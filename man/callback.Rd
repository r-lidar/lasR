% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stages.R
\name{callback}
\alias{callback}
\title{Call a user-defined function on the point cloud}
\usage{
callback(fun, expose = "xyz", ..., drop_buffer = FALSE, no_las_update = FALSE)
}
\arguments{
\item{fun}{function. A user-defined function that takes as first argument a \code{data.frame} with the exposed
point cloud attributes (see examples).}

\item{expose}{character. Expose only attributes of interest to save memory (see details).}

\item{...}{parameters of function \code{fun}}

\item{drop_buffer}{bool. If false, does not expose the point from the buffer.}

\item{no_las_update}{bool. If the user-defined function returns a data.frame, this is supposed to
update the point cloud. Can be disabled.}
}
\value{
This stage transforms the point cloud in the pipeline. It consequently returns nothing.
}
\description{
Call a user-defined function on the point cloud. The function receives a \code{data.frame} with the
point cloud. Its first input must be the point cloud. If the function returns anything other than
a \code{data.frame} with the same number of points, the output is stored and returned at the end. However,
if the output is a \code{data.frame} with the same number of points, it updates the point cloud. This
function can, therefore, be used to modify the point cloud using a user-defined function. The function
is versatile but complex. A more comprehensive set of examples can be found in the
\href{https://r-lidar.github.io/lasR/articles/tutorial.html#callback}{online tutorial}.
}
\details{
In \code{lasR}, the point cloud is not exposed to R in a \code{data.frame} like in lidR. It is stored internally
in a C++ structure and cannot be seen or modified directly by users using R code. The \code{callback} function
is the only stage that allows direct interaction with the point cloud by \strong{copying} it
temporarily into a \code{data.frame} to apply a user-defined function.\cr\cr
\strong{expose:} the 'expose' argument specifies the data that will actually be exposed to R. For example,
'xyzia' means that the x, y, and z coordinates, the intensity, and the scan angle will be exposed.
The supported entries are t - gpstime, a - scan angle, i - intensity, n - number of returns,
r - return number, c - classification, u - user data, p - point source ID, e - edge of flight line flag,
R - red channel of RGB color, G - green channel of RGB color, B - blue channel of RGB color,
N - near-infrared channel, C - scanner channel (format 6+)
Also numbers from 1 to 9 for the extra attributes data numbers 1 to 9. 'E' enables all extra attribute to be
loaded. '*' is the wildcard that enables everything to be exposed from the point cloud
}
\examples{
f <- system.file("extdata", "Topography.las", package = "lasR")

# There is no function in lasR to read the data in R. Let's create one
read_las <- function(f)
{
  load <- function(data) { return(data) }
  read <- reader()
  call <- callback(load, expose = "xyzi", no_las_update = TRUE)
  return (exec(read + call, on = f))
}
las <- read_las(f)
head(las)

convert_intensity_in_range <- function(data, min, max)
{
  i <- data$Intensity
  i <- ((i - min(i)) / (max(i) - min(i))) * (max - min) + min
  i[i < min] <- min
  i[i > max] <- max
  data$Intensity <- as.integer(i)
  return(data)
}

read <- reader()
call <- callback(convert_intensity_in_range, expose = "i", min = 0, max = 255)
write <- write_las()
pipeline <- read + call + write
ans <- exec(pipeline, on = f)

las <- read_las(ans)
head(las)

}
\seealso{
\link{write_las}
}
